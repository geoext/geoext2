<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">describe(&quot;Ext.Array&quot;, function() {
    var array;

    describe(&quot;Ext.Array.indexOf&quot;, function() {
        describe(&quot;without from argument&quot;, function() {
            beforeEach(function() {
                array = [1, 2, 3, 4, 5, 6];
            });

            afterEach(function(){
                array = null;
            });

            it(&quot;should always return -1 on an empty array&quot;, function(){
                expect(Ext.Array.indexOf([], 1)).toEqual(-1);
            });

            it(&quot;should return -1 if them it doesn't exist&quot;, function() {
                expect(Ext.Array.indexOf(array, 7)).toEqual(-1);
            });

            it(&quot;should return the matching index if found&quot;, function() {
                expect(Ext.Array.indexOf(array, 4)).toEqual(3);
            });

            it(&quot;should return the first matching index if found&quot;, function(){
                array.push(1);
                expect(Ext.Array.indexOf(array, 1)).toEqual(0);
            });
        });

        describe(&quot;with from argument&quot;, function() {
            beforeEach(function() {
                array = [1, 2, 3, 4, 5, 6, 7];
            });

            it(&quot;should return the matched index if found&quot;, function() {
                expect(Ext.Array.indexOf(array, 5, 3)).toEqual(4);
                expect(Ext.Array.indexOf(array, 5, 4)).toEqual(4);
            });

            it(&quot;should return -1 if the item doesn't exist after the passed from value&quot;, function() {
                expect(Ext.Array.indexOf(array, 5, 5)).toEqual(-1);
            });
        });

    });
    describe(&quot;removing items&quot;, function() {
        var myArray;

        it(&quot;should do nothing when removing from an empty array&quot;, function() {
            myArray = [];

            expect(function() {
                Ext.Array.remove(myArray, 1);
            }).not.toRaiseExtError();

            expect(myArray).toEqual([]);
        });

        describe(&quot;when removing an item inside an array&quot;, function() {
            beforeEach(function() {
                myArray = [1, 2, 3, 4, 5];

                Ext.Array.remove(myArray, 1);
            });

            it(&quot;should remove the item&quot;, function() {
                expect(myArray).toEqual([2, 3, 4, 5]);
            });

            it(&quot;should update the index of the following items&quot;, function() {
                expect(myArray[1]).toEqual(3);
                expect(myArray[2]).toEqual(4);
                expect(myArray[3]).toEqual(5);
            });

            it(&quot;should remove only using a strict type check&quot;, function(){
                Ext.Array.remove(myArray, '2');
                expect(myArray).toEqual([2, 3, 4, 5]);
            });
        });
    });

    describe(&quot;contains&quot;, function() {
        it(&quot;should always return false with an empty array&quot;, function(){
            expect(Ext.Array.contains([], 1)).toBe(false);
        });

        it(&quot;should return false if an item does not exist in the array&quot;, function() {
            expect(Ext.Array.contains([1, 2, 3], 10)).toBe(false);
        });

        it(&quot;should return true if an item exists in the array&quot;, function() {
            expect(Ext.Array.contains([8, 9, 10], 10)).toBe(true);
        });

        it(&quot;should only match with strict type checking&quot;, function(){
            expect(Ext.Array.contains([1, 2, 3, 4, 5], '1')).toBe(false);
        });
    });

    describe(&quot;include&quot;, function(){
        var myArray;

        it(&quot;should always add to an empty array&quot;, function(){
            myArray = [];
            Ext.Array.include(myArray, 1);
            expect(myArray).toEqual([1]);
        });

        it(&quot;should add the item if it doesn't exist&quot;, function(){
            myArray = [1];
            Ext.Array.include(myArray, 2);
            expect(myArray).toEqual([1, 2]);
        });

        it(&quot;should always add to the end of the array&quot;, function(){
            myArray = [9, 8, 7, 6];
            Ext.Array.include(myArray, 10);
            expect(myArray).toEqual([9, 8, 7, 6, 10]);
        });

        it(&quot;should match using strict type checking&quot;, function(){
            myArray = ['1'];
            Ext.Array.include(myArray, 1);
            expect(myArray).toEqual(['1', 1]);
        });

        it(&quot;should not modify the array if the value exists&quot;, function(){
            myArray = [4, 5, 6];
            Ext.Array.include(myArray, 7);
            expect(myArray).toEqual([4, 5, 6, 7]);
        });
    });

    describe(&quot;clone&quot;, function(){
        it(&quot;should clone an empty array to be empty&quot;, function(){
            expect(Ext.Array.clone([])).toEqual([]);
        });

        it(&quot;should clone an array with items&quot;, function(){
            expect(Ext.Array.clone([1, 3, 5])).toEqual([1, 3, 5]);
        });

        it(&quot;should create a new reference&quot;, function(){
            var arr = [1, 2, 3];
            expect(Ext.Array.clone(arr)).not.toBe(arr);
        });

        it(&quot;should do a shallow clone&quot;, function(){
            var o = {},
                arr = [o],
                result;

            result = Ext.Array.clone(arr);
            expect(result[0]).toBe(o);
        });
    });

    describe(&quot;clean&quot;, function(){
        it(&quot;should return an empty array if cleaning an empty array&quot;, function(){
            expect(Ext.Array.clean([])).toEqual([]);
        });

        it(&quot;should remove undefined values&quot;, function(){
            expect(Ext.Array.clean([undefined])).toEqual([]);
        });

        it(&quot;should remove null values&quot;, function(){
            expect(Ext.Array.clean([null])).toEqual([]);
        });

        it(&quot;should remove empty strings&quot;, function(){
            expect(Ext.Array.clean([''])).toEqual([]);
        });

        it(&quot;should remove empty arrays&quot;, function(){
            expect(Ext.Array.clean([[]])).toEqual([]);
        });

        it(&quot;should remove a mixture of empty values&quot;, function(){
            expect(Ext.Array.clean([null, undefined, '', []])).toEqual([]);
        });

        it(&quot;should remove all occurrences of empty values&quot;, function(){
            expect(Ext.Array.clean([null, null, null, undefined, '', '', '', undefined])).toEqual([]);
        });

        it(&quot;should leave non empty values untouched&quot;, function(){
            expect(Ext.Array.clean([1, 2, 3])).toEqual([1, 2, 3]);
        });

        it(&quot;should remove only the empty values&quot;, function(){
            expect(Ext.Array.clean([undefined, null, 1, null, 2])).toEqual([1, 2]);
        });

        it(&quot;should preserve order on removal&quot;, function(){
            expect(Ext.Array.clean([1, null, 2, null, null, null, 3, undefined, '', '', 4])).toEqual([1, 2, 3, 4]);
        });
    });

    describe(&quot;unique&quot;, function(){

        it(&quot;should return an empty array if run on an empty array&quot;, function(){
            expect(Ext.Array.unique([])).toEqual([]);
        });

        it(&quot;should return a new reference&quot;, function(){
            var arr = [1, 2, 3];
            expect(Ext.Array.unique(arr)).not.toBe(arr);
        });

        it(&quot;should return a copy if all items are unique&quot;, function(){
            expect(Ext.Array.unique([6, 7, 8])).toEqual([6, 7, 8]);
        });

        it(&quot;should only use strict typing to match&quot;, function(){
            expect(Ext.Array.unique([1, '1'])).toEqual([1, '1']);
        });

        it(&quot;should preserve the order when removing&quot;, function(){
            expect(Ext.Array.unique([1, 2, 1, 3, 1, 1, 1, 6, 5, 1])).toEqual([1, 2, 3, 6, 5]);
        });
    });

    describe(&quot;map&quot;, function(){
        var emptyFn = function(v){
                return v;
            };

        it(&quot;should return an empty array if run on an empty array&quot;, function(){
            expect(Ext.Array.map([], function(){})).toEqual([]);
        });

        it(&quot;should return a new reference&quot;, function(){
            var arr = [1, 2];
            expect(Ext.Array.map(arr, emptyFn)).not.toBe(arr);
        });

        it(&quot;should execute the function for each item in the array&quot;, function(){
            expect(Ext.Array.map([1, 2, 3, 4, 5], function(v){
                return v * 2;
            })).toEqual([2, 4, 6, 8, 10]);
        });

        it(&quot;should get called with the correct scope&quot;, function(){
            var scope = {},
                realScope;
            Ext.Array.map([1, 2, 3, 4, 5], function(){
                realScope = this;
            }, scope);
            expect(realScope).toBe(scope);
        });

        it(&quot;should get called with the argument, index and array&quot;, function(){
            var item,
                index,
                arr,
                data = [1];

            Ext.Array.map(data, function(){
                item = arguments[0];
                index = arguments[1];
                arr = arguments[2];
            });
            expect(item).toEqual(1);
            expect(index).toEqual(0);
            expect(arr).toBe(data);
        });
    });

    describe(&quot;from&quot;, function(){
        it(&quot;should return an empty array for an undefined value&quot;, function(){
            expect(Ext.Array.from(undefined)).toEqual([]);
        });

        it(&quot;should return an empty array for a null value&quot;, function(){
            expect(Ext.Array.from(null)).toEqual([]);
        });

        it(&quot;should convert an array&quot;, function(){
            expect(Ext.Array.from([1, 2, 3])).toEqual([1, 2, 3]);
        });

        it(&quot;should preserve the order&quot;, function(){
            expect(Ext.Array.from(['a', 'string', 'here'])).toEqual(['a', 'string', 'here']);
        });

        it(&quot;should convert a single value to an array&quot;, function(){
            expect(Ext.Array.from(true)).toEqual([true]);
            expect(Ext.Array.from(700)).toEqual([700]);
        });

        it(&quot;should convert arguments to an array&quot;, function(){
            var test, fn = function(){
                test = Ext.Array.from(arguments);
            };
            fn(1, 2, 3);
            expect(test instanceof Array).toBeTruthy();
            expect(test).toEqual([1, 2, 3]);
        });

        it(&quot;should convert a DOM collection to an array&quot;, function(){
            var ct = document.body.appendChild(document.createElement('div')),
                node1 = ct.appendChild(document.createElement('div')),
                node2 = ct.appendChild(document.createElement('div')),
                node3 = ct.appendChild(document.createElement('div')),
                collection = ct.getElementsByTagName('div'),
                result = Ext.Array.from(collection);

            expect(result instanceof Array).toBeTruthy();
            expect(result).toEqual([node1, node2, node3]);
            document.body.removeChild(ct);
        });
        
        it(&quot;should convert a single string&quot;, function(){
            expect(Ext.Array.from('Foo')).toEqual(['Foo']);
        });
        
        it(&quot;should convert a single string&quot;, function(){
            var fn = function(){};
            expect(Ext.Array.from(fn)).toEqual([fn]);
        });
    });

    describe(&quot;toArray&quot;, function(){
        it(&quot;should convert an array&quot;, function(){
            expect(Ext.Array.toArray([1, 2, 3, 4])).toEqual([1, 2, 3, 4]);
        });

        it(&quot;should convert a string&quot;, function(){
            expect(Ext.Array.toArray('12345')).toEqual(['1', '2', '3', '4', '5']);
        });

        it(&quot;should create a new reference&quot;, function(){
            var arr = [6, 7, 8];
            expect(Ext.Array.toArray(arr)).not.toBe(arr);
        });

        it(&quot;should convert arguments&quot;, function(){
            var test, fn = function(){
                test = Ext.Array.toArray(arguments);
            };
            fn(-1, -2, -3);
            expect(test instanceof Array).toBeTruthy();
            expect(test).toEqual([-1, -2, -3]);
        });

        it(&quot;should convert a DOM collection&quot;, function(){
            var ct = document.body.appendChild(document.createElement('div')),
                node1 = ct.appendChild(document.createElement('div')),
                node2 = ct.appendChild(document.createElement('div')),
                node3 = ct.appendChild(document.createElement('div')),
                collection = ct.getElementsByTagName('div'),
                result = Ext.Array.toArray(collection);

            expect(result instanceof Array).toBeTruthy();
            expect(result).toEqual([node1, node2, node3]);
            document.body.removeChild(ct);
        });

        describe(&quot;start/end parameters&quot;, function(){
            it(&quot;should default to whole of the array&quot;, function(){
                expect(Ext.Array.toArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
            });

            it(&quot;should work with only the start parameter specified&quot;, function(){
                expect(Ext.Array.toArray([1, 2, 3, 4, 5, 6], 2)).toEqual([3, 4, 5, 6]);
            });

            it(&quot;should work with only the end parameter specified&quot;, function(){
                expect(Ext.Array.toArray([1, 2, 3, 4, 5, 6], null, 4)).toEqual([1, 2, 3, 4]);
            });

            it(&quot;should work with both params specified&quot;, function(){
                expect(Ext.Array.toArray([1, 2, 3, 4, 5, 6], 2, 4)).toEqual([3, 4]);
            });

            it(&quot;should work with nagative end&quot;, function(){
                expect(Ext.Array.toArray([1, 2, 3, 4, 5, 6], 2, -1)).toEqual([3, 4, 5]);
            });
        });
    });

    describe(&quot;pluck&quot;, function(){
        it(&quot;should return an empty array when an empty array is passed&quot;, function(){
            expect(Ext.Array.pluck([], 'prop')).toEqual([]);
        });

        it(&quot;should pull the properties from objects in the array&quot;, function(){
            var arr = [{prop: 1}, {prop: 2}, {prop: 3}];
            expect(Ext.Array.pluck(arr, 'prop')).toEqual([1, 2, 3]);
        });

        it(&quot;should return a new reference&quot;, function(){
            var arr = [{prop: 1}, {prop: 2}, {prop: 3}];
            expect(Ext.Array.pluck(arr, 'prop')).not.toBe(arr);
        });

        it(&quot;should work on a DOM collection&quot;, function(){
            var ct = document.body.appendChild(document.createElement('div')),
                i = 0,
                node;

            for(; i &lt; 5; ++i) {
                node = ct.appendChild(document.createElement('div'));
                node.className = 'node' + i;
            }

            expect(Ext.Array.pluck(ct.getElementsByTagName('div'), 'className')).toEqual(['node0', 'node1', 'node2', 'node3', 'node4']);
            document.body.removeChild(ct);
        });
    });

    describe(&quot;filter&quot;, function(){
        var trueFn = function(){
                return true;
            };

        it(&quot;should return an empty array if filtering an empty array&quot;, function(){
            expect(Ext.Array.filter([], trueFn)).toEqual([]);
        });

        it(&quot;should create a new reference&quot;, function(){
            var arr = [1, 2, 3];
            expect(Ext.Array.filter(arr, trueFn)).not.toBe(arr);
        });

        it(&quot;should add items if the filter function returns true&quot;, function(){
            expect(Ext.Array.filter([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(val){
                return val % 2 === 0;
            })).toEqual([2, 4, 6, 8, 10]);
        });

        it(&quot;should add items if the filter function returns a truthy value&quot;, function(){
            expect(Ext.Array.filter([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(val){
                if (val % 2 === 0) {
                    return 1;
                }
            })).toEqual([2, 4, 6, 8, 10]);
        });

        it(&quot;should not add items if the filter function returns a falsy value&quot;, function(){
            expect(Ext.Array.filter([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(val){
                return 0;
            })).toEqual([]);
        });

        it(&quot;should pass the correct parameters&quot;, function(){
            var values = [],
                indexes = [],
                arrs = [],
                data = [1, 2, 3];

            Ext.Array.filter([1, 2, 3], function(val, index, arr){
                values.push(val);
                indexes.push(index);
                arrs.push(arr);
            });

            expect(values).toEqual([1, 2, 3]);
            expect(indexes).toEqual([0, 1, 2]);
            expect(arrs).toEqual([data, data, data]);
        });

        it(&quot;should do a shallow copy&quot;, function(){
            var o1 = {prop: 1},
                o2 = {prop: 2},
                o3 = {prop: 3};

            expect(Ext.Array.filter([o1, o2, o3], trueFn)).toEqual([o1, o2, o3]);
        });

        it(&quot;should execute in scope when passed&quot;, function(){
            var scope = {},
                actual;

            expect(Ext.Array.filter([1, 2, 3], function(){
                actual = this;
            }, scope));
            expect(actual).toBe(scope);
        });
    });

    describe(&quot;forEach&quot;, function(){
        it(&quot;should not execute on an empty array&quot;, function(){
            var count = 0;
            Ext.Array.forEach([], function(){
                ++count;
            });
            expect(count).toEqual(0);
        });

        it(&quot;should execute for each item in the array&quot;, function(){
            var count = 0;
            Ext.Array.forEach([1, 2, 3, 4, 5], function(){
                ++count;
            });
            expect(count).toEqual(5);
        });

        it(&quot;should execute in the appropriate scope&quot;, function(){
            var scope = {},
                actual;

            Ext.Array.forEach([1, 2, 3], function(){
                actual = this;
            }, scope);

            expect(actual).toBe(scope);
        });

        it(&quot;should pass the appropriate params to the callback&quot;, function(){
            var values = [],
                indexes = [],
                arrs = [],
                data = [1, 2, 3];

            Ext.Array.forEach(data, function(val, index, arr){
                values.push(val);
                indexes.push(index);
                arrs.push(arr);
            });

            expect(values).toEqual([1, 2, 3]);
            expect(indexes).toEqual([0, 1, 2]);
            expect(arrs).toEqual([data, data, data]);
        });
    });

    describe(&quot;each&quot;, function(){
        describe(&quot;return values&quot;, function(){
            xit(&quot;should return 0 if the passed value is empty&quot;, function(){
                expect(Ext.Array.each([])).toEqual(0);
            });

            it(&quot;should return the stopping index if iteration is halted&quot;, function(){
                expect(Ext.Array.each([1, 2, 3], function(val){
                    return val != 2;
                })).toEqual(1);
            });

            it(&quot;should return true if iteration is not stopped&quot;, function(){
                expect(Ext.Array.each([4, 5, 6], function(){
                    return true;
                })).toBeTruthy();
            });
        });

        describe(&quot;scope/parameters&quot;, function(){
            it(&quot;should execute in the specified scope&quot;, function(){
                var scope = {},
                    actual;

                Ext.Array.each([1, 2, 3], function(){
                    actual = this;
                }, scope);
                expect(actual).toBe(scope);
            });

            it(&quot;should pass the item, index and array&quot;, function(){
                var values = [],
                    indexes = [],
                    arrs = [],
                    data = [1, 2, 3];

                Ext.Array.each(data, function(val, index, arr){
                    values.push(val);
                    indexes.push(index);
                    arrs.push(arr);
                });

                expect(values).toEqual([1, 2, 3]);
                expect(indexes).toEqual([0, 1, 2]);
                expect(arrs).toEqual([data, data, data]);
            });
        });

        describe(&quot;stopping iteration&quot;, function(){
            it(&quot;should not stop iteration by default&quot;, function(){
                var count = 0;
                Ext.Array.each([1, 2, 3, 4, 5], function(){
                    ++count;
                });
                expect(count).toEqual(5);
            });

            it(&quot;should not stop unless an explicit false is returned&quot;, function(){
                var count = 0;
                Ext.Array.each([1, 2, 3, 4, 5], function(){
                    ++count;
                    return null;
                });
                expect(count).toEqual(5);
            });

            it(&quot;should stop immediately if false is returned&quot;, function(){
                var count = 0;
                Ext.Array.each([1, 2, 3, 4, 5], function(v){
                    ++count;
                    return v != 2;
                });
                expect(count).toEqual(2);
            });
        });

        describe(&quot;other collection types&quot;, function(){
            it(&quot;should iterate arguments&quot;, function(){
                var test, values = [], fn = function(){
                    test = Ext.Array.each(arguments, function(val){
                        values.push(val);
                    });
                };
                fn(1, 2, 3);
                expect(values).toEqual([1, 2, 3]);
            });

            it(&quot;should iterate over a DOM collection&quot;, function(){
                var ct = document.body.appendChild(document.createElement('div')),
                    node1 = ct.appendChild(document.createElement('div')),
                    node2 = ct.appendChild(document.createElement('div')),
                    node3 = ct.appendChild(document.createElement('div')),
                    collection = ct.getElementsByTagName('div'),
                    result = [];

                Ext.Array.each(collection, function(node){
                    result.push(node.tagName.toLowerCase());
                });

                expect(result).toEqual(['div', 'div', 'div']);
                document.body.removeChild(ct);
            });
        });

        it(&quot;should iterate once over a single, non empty value&quot;, function(){
            var count = 0;
            Ext.Array.each('string', function(){
                ++count;
            });
            expect(count).toEqual(1);
        });
        
        describe(&quot;reverse iteraction&quot;, function() {
            it(&quot;should iterate backwards&quot;, function() {
                var output = [],
                    input = [1, 2, 3],
                    fn = function(number) {
                        output.push(number);
                    };
                Ext.Array.each(input, fn, undefined, true);
                expect(output).toEqual([3, 2, 1]);
            });
            it(&quot;should iterate backwards and stop when fn returns false&quot;, function() {
                var output = [],
                    input = [1, 2, 3],
                    fn = function(number) {
                        output.push(number);
                        if (number === 2) { return false; }
                    };
                Ext.Array.each(input, fn, undefined, true);
                expect(output).toEqual([3, 2]);
            });
        });
    });

    describe(&quot;every&quot;, function(){
        describe(&quot;scope/params&quot;, function(){
            it(&quot;should execute in the specified scope&quot;, function(){
                var scope = {},
                    actual;

                Ext.Array.every([1, 2, 3], function(){
                    actual = this;
                }, scope);
                expect(actual).toBe(scope);
            });

            it(&quot;should pass the item, index and array&quot;, function(){
                var values = [],
                    indexes = [],
                    arrs = [],
                    data = [1, 2, 3];

                Ext.Array.every(data, function(val, index, arr){
                    values.push(val);
                    indexes.push(index);
                    arrs.push(arr);
                    return true;
                });

                expect(values).toEqual([1, 2, 3]);
                expect(indexes).toEqual([0, 1, 2]);
                expect(arrs).toEqual([data, data, data]);
            });
        });

        it(&quot;should return true on an empty array&quot;, function(){
            expect(Ext.Array.every([], function(){})).toBeTruthy();
        });

        it(&quot;should throw an exception if no fn is passed&quot;, function(){
            expect(function(){
                Ext.Array.every([1, 2, 3]);
            }).toRaiseExtError();
        });

        it(&quot;should stop as soon as a false value is found&quot;, function(){
            var count = 0,
                result;

            result = Ext.Array.every([true, true, false, true], function(v){
                ++count;
                return v;
            });
            expect(count).toEqual(3);
            expect(result).toBeFalsy();
        });

        it(&quot;should return true if all values match the function&quot;, function(){
            expect(Ext.Array.every([1, 2, 3, 4, 5, 6, 7, 8, 9], function(v){
                return v &lt; 10;
            })).toBeTruthy();
        });
    });

    describe(&quot;some&quot;, function(){
        describe(&quot;scope/params&quot;, function(){
            it(&quot;should execute in the specified scope&quot;, function(){
                var scope = {},
                    actual;

                Ext.Array.some([1, 2, 3], function(){
                    actual = this;
                }, scope);
                expect(actual).toBe(scope);
            });

            it(&quot;should pass the item, index and array&quot;, function(){
                var values = [],
                    indexes = [],
                    arrs = [],
                    data = [1, 2, 3];

                Ext.Array.some(data, function(val, index, arr){
                    values.push(val);
                    indexes.push(index);
                    arrs.push(arr);
                    return true;
                });

                expect(values).toEqual([1]);
                expect(indexes).toEqual([0]);
                expect(arrs).toEqual([data]);
            });
        });

        it(&quot;should return false on an empty array&quot;, function(){
            expect(Ext.Array.some([], function(){})).toBeFalsy();
        });

        it(&quot;should throw an exception if no fn is passed&quot;, function(){
            expect(function(){
                Ext.Array.some([1, 2, 3]);
            }).toRaiseExtError();
        });

        it(&quot;should stop as soon as a matching value is found&quot;, function(){
            var count = 0,
                result;

            result = Ext.Array.some([1, 2, 3, 4], function(val){
                ++count;
                return val == 3;
            });
            expect(count).toEqual(3);
            expect(result).toBeTruthy();
        });

        it(&quot;should return false if nothing matches the matcher function&quot;, function(){
            var count = 0,
                result;

            result = Ext.Array.some([1, 2, 3, 4, 5, 6, 7, 8, 9], function(val){
                ++count;
                return val &gt; 9;
            });
            expect(count).toEqual(9);
            expect(result).toBeFalsy();
        });
    });

    describe(&quot;merge&quot;, function(){
        it(&quot;should return an empty array if run on an empty array&quot;, function(){
            expect(Ext.Array.merge([])).toEqual([]);
        });

        it(&quot;should return a new reference&quot;, function(){
            var arr = [1, 2, 3];
            expect(Ext.Array.merge(arr)).not.toBe(arr);
        });

        it(&quot;should return a copy if all items are unique&quot;, function(){
            expect(Ext.Array.merge([6, 7, 8])).toEqual([6, 7, 8]);
        });

        it(&quot;should only use strict typing to match&quot;, function(){
            expect(Ext.Array.merge([1, '1'])).toEqual([1, '1']);
        });

        it(&quot;should accept two or more arrays and return a unique union with items in order of first appearance&quot;, function(){
            expect(Ext.Array.merge([1, 2, 3], ['1', '2', '3'], [4, 1, 5, 2], [6, 3, 7, '1'], [8, '2', 9, '3'])).toEqual([1, 2, 3, '1', '2', '3', 4, 5, 6, 7, 8, 9]);
        });
    });

    describe(&quot;intersect&quot;, function(){
        it(&quot;should return an empty array if no arrays are passed&quot;, function(){
            expect(Ext.Array.intersect()).toEqual([]);
        });

        it(&quot;should return an empty array if one empty array is passed&quot;, function(){
            expect(Ext.Array.intersect([])).toEqual([]);
        });

        it(&quot;should return a new reference&quot;, function(){
            var arr = [1, 2, 3];
            expect(Ext.Array.intersect(arr)).not.toBe(arr);
        });

        it(&quot;should return a copy if one array is passed&quot;, function(){
            expect(Ext.Array.intersect([6, 7, 8])).toEqual([6, 7, 8]);
        });

        it(&quot;should return an intersection of two or more arrays with items in order of first appearance&quot;, function(){
            expect(Ext.Array.intersect([1, 2, 3], [4, 3, 2, 5], [2, 6, 3])).toEqual([2, 3]);
        });

        it(&quot;should return an empty array if there is no intersecting values&quot;, function(){
            expect(Ext.Array.intersect([1, 2, 3], [4, 5, 6])).toEqual([]);
        });

        it(&quot;should contain the unique set of intersected values only&quot;, function(){
            expect(Ext.Array.intersect([1, 1, 2, 3, 3], [1, 1, 2, 3, 3])).toEqual([1, 2, 3]);
        });

        it(&quot;should only use strict typing to match&quot;, function(){
            expect(Ext.Array.intersect([1], ['1'])).toEqual([]);
        });
        it(&quot;should handle arrays containing falsy values&quot;, function() {
            expect(Ext.Array.intersect([undefined, null, false, 0, ''], [undefined, null, false, 0, ''])).toEqual([undefined, null, false, 0, '']); 
        });
    });

    describe(&quot;difference&quot;, function(){
        it(&quot;should return a set difference of two arrays with items in order of first appearance&quot;, function(){
            expect(Ext.Array.difference([1, 2, 3, 4], [3, 2])).toEqual([1, 4]);
        });

        it(&quot;should return the first array unchanged if there is no difference&quot;, function(){
            expect(Ext.Array.difference([1, 2, 3], [4, 5, 6])).toEqual([1, 2, 3]);
        });

        it(&quot;should return a new reference&quot;, function(){
            var arr = [1, 2, 3];
            expect(Ext.Array.difference(arr, [3, 2])).not.toBe(arr);
        });

        it(&quot;should remove multiples of the same value from the first array&quot;, function(){
            expect(Ext.Array.difference([1, 2, 3, 2, 4, 1], [2, 1])).toEqual([3, 4]);
        });

        it(&quot;should only use strict typing to match&quot;, function(){
            expect(Ext.Array.difference([1], ['1'])).toEqual([1]);
        });
    });

    describe(&quot;sort&quot;, function() {
       var sarray, narray;
       beforeEach(function() {
          sarray = ['bbb', 'addda', 'erere', 'fff', 'de3'];
          narray = [1,3,2,4,6,7];

       });

       describe(&quot;with strings&quot;, function() {
           it(&quot;should be able to sort an array without sortFn&quot;, function() {
                Ext.Array.sort(sarray);
                expect(sarray).toEqual(['addda', 'bbb', 'de3', 'erere', 'fff']);
           });


           it(&quot;should be able to use a sortFn that returns a Number&quot;, function() {
                Ext.Array.sort(sarray, function(a,b){
                    if (a === b) {
                        return 0;
                    }
                    return  a &gt; b ? 1: -1;
                });
                expect(sarray).toEqual(['addda', 'bbb', 'de3', 'erere', 'fff']);
           });
       });

       describe(&quot;with numbers&quot;, function() {
           it(&quot;should be able to sort an array without sortFn&quot;, function() {
                Ext.Array.sort(narray);
                expect(narray).toEqual([1,2,3,4,6,7]);
           });


           it(&quot;should be able to use a sortFn that returns a Number&quot;, function() {
                Ext.Array.sort(narray, function(a,b){
                    return a - b;
                });
                expect(narray).toEqual([1,2,3,4,6,7]);
           });
       });
    });

    describe(&quot;min&quot;, function() {
        describe(&quot;numbers&quot;, function() {
            it(&quot;without comparisonFn&quot;, function() {
                expect(Ext.Array.min([1,2,3,4,5,6])).toEqual(1);
                expect(Ext.Array.min([6,5,4,3,2,1])).toEqual(1);
            });

            it(&quot;with comparisonFn&quot;, function() {
                expect(Ext.Array.min([1,2,3,4,5,6], function(a, b) { return a &lt; b ? 1 : -1; })).toEqual(6);
            });
        });
    });

    describe(&quot;max&quot;, function() {
        describe(&quot;numbers&quot;, function() {
            it(&quot;without comparisonFn&quot;, function() {
                expect(Ext.Array.max([1,2,3,4,5,6])).toEqual(6);
            });

            it(&quot;with comparisonFn&quot;, function() {
                expect(Ext.Array.max([1,2,3,4,5,6], function(a, b) { return a &lt; b ? 1 : -1; })).toEqual(1);
            });
        });
    });

    describe(&quot;sum&quot;, function() {
        it(&quot;should return 21&quot;, function() {
            expect(Ext.Array.sum([1,2,3,4,5,6])).toEqual(21);
        });
    });

    describe(&quot;mean&quot;, function() {
        it(&quot;should return 3.5&quot;, function() {
            expect(Ext.Array.mean([1,2,3,4,5,6])).toEqual(3.5);
        });
    });

    function testReplace (replace) {
        it('should remove items in the middle', function () {
            var array = [0, 1, 2, 3, 4, 5, 6, 7];
            replace(array, 2, 2);
            expect(Ext.encode(array)).toEqual('[0,1,4,5,6,7]');
        });
        it('should insert items in the middle', function () {
            var array = [0, 1, 2, 3, 4, 5, 6, 7];
            replace(array, 2, 0, ['a','b']);
            expect(Ext.encode(array)).toEqual('[0,1,&quot;a&quot;,&quot;b&quot;,2,3,4,5,6,7]');
        });
        it('should replace in the middle with more items', function () {
            var array = [0, 1, 2, 3, 4, 5, 6, 7];
            replace(array, 2, 2, ['a','b', 'c', 'd']);
            expect(Ext.encode(array)).toEqual('[0,1,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,4,5,6,7]');
        });
        it('should replace in the middle with fewer items', function () {
            var array = [0, 1, 2, 3, 4, 5, 6, 7];
            replace(array, 2, 4, ['a','b']);
            expect(Ext.encode(array)).toEqual('[0,1,&quot;a&quot;,&quot;b&quot;,6,7]');
        });
        it('should delete at front', function () {
            var array = [0, 1, 2, 3];
            replace(array, 0, 2);
            expect(Ext.encode(array)).toEqual('[2,3]');
        });
        it('should delete at tail', function () {
            var array = [0, 1, 2, 3];
            replace(array, 2, 2);
            expect(Ext.encode(array)).toEqual('[0,1]');
        });
        it('should delete everything', function () {
            var array = [0, 1, 2, 3];
            replace(array, 0, 4);
            expect(Ext.encode(array)).toEqual('[]');
        });
        it('should insert at front', function () {
            var array = [0, 1];
            replace(array, 0, 0, ['a','b','c','d','e']);
            expect(Ext.encode(array)).toEqual('[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,0,1]');
        });
        it('should insert at tail', function () {
            var array = [0, 1];
            replace(array, array.length, 0, ['a','b','c','d','e']);
            expect(Ext.encode(array)).toEqual('[0,1,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]');
        });
        it('should insert into empty array', function () {
            var array = [];
            replace(array, 0, 0, ['a','b','c','d','e']);
            expect(Ext.encode(array)).toEqual('[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]');
        });
        it('should replace at front', function () {
            var array = [0, 1];
            replace(array, 0, 1, ['a','b','c','d','e']);
            expect(Ext.encode(array)).toEqual('[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,1]');
        });
        it('should replace at tail', function () {
            var array = [0, 1];
            replace(array, 1, 1, ['a','b','c','d','e']);
            expect(Ext.encode(array)).toEqual('[0,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]');
        });
        it('should replace entire array', function () {
            var array = [0, 1, 2, 3];
            replace(array, 0, array.length, ['a','b','c','d','e']);
            expect(Ext.encode(array)).toEqual('[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]');
        });
        it('should handle negative index', function () {
            var array = [0, 1, 2, 3];
            replace(array, -2, 20); // should clip
            expect(Ext.encode(array)).toEqual('[0,1]');
        });
        it('should work around the IE8 bug', function () {
            // see http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/6e946d03-e09f-4b22-a4dd-cd5e276bf05a/
            var array = [],
                lengthBefore,
                j = 20;

            while (j--) {
                array.push(&quot;A&quot;);
            }

            array.splice(15, 0, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;);
            // the fact that this is an APPLY is not instrumental to reproducing this bug

            lengthBefore = array.length; // = 41

            // everything above should be exactly preserved including the true splice call.
            // That way we have produced the Array Time Bomb... now see if it explodes!

            replace(array, 13, 0, [&quot;XXX&quot;]); // add one element (this was the failure)

            expect(array.length).toEqual(lengthBefore+1);
        });
    }

    describe('replaceSim', function () {
        // The _replace method is our corrected method for IE8, but we make it available (in
        // debug builds) on all browsers to see that it works.
        testReplace(Ext.Array._replaceSim);
    });

    describe('replaceNative', function () {
        // and test the wrapper on other browsers
        testReplace(Ext.Array.replace);
    });

    describe('splice', function () {
        it('returns proper result array at the front', function () {
            var ret = Ext.Array._spliceSim([1,2,3,4], 0, 2);
            expect(Ext.encode(ret)).toEqual('[1,2]');
        });
        it('returns proper result array at the end', function () {
            var ret = Ext.Array._spliceSim([1,2,3,4], 2, 2);
            expect(Ext.encode(ret)).toEqual('[3,4]');
        });
        it('returns proper result array from the middle', function () {
            var ret = Ext.Array._spliceSim([1,2,3,4], 1, 2);
            expect(Ext.encode(ret)).toEqual('[2,3]');
        });
        it('return an empty array when nothing removed', function () {
            var ret = Ext.Array._spliceSim([1,2,3,4], 1, 0);
            expect(Ext.encode(ret)).toEqual('[]');
        });
    });

    describe('slice', function(){

        var array;

        describe('with Array', function(){
            beforeEach(function(){
                array = [{0:0}, {1:1}, {2:2}, {3:3}];
            });
            tests();
        });

        describe('with arguments', function(){
            beforeEach(function(){
                array = (function(){ return arguments; })({0:0}, {1:1}, {2:2}, {3:3});
            });
            tests();
        });

        function tests(){
            it('should shallow clone', function(){
                var newArray = Ext.Array.slice(array, 0);
                expect(newArray === array).toBe(false);
                expect(newArray[0] === array[0]).toBe(true);
            });
            it('should not require a begin or end', function(){
                var newArray = Ext.Array.slice(array);
                expect(newArray === array).toBe(false);
                expect(newArray[0]).toBe(array[0]);
            });
            it('should slice off the first item', function(){
                var newArray = Ext.Array.slice(array, 1);
                expect(newArray.length).toBe(3);
                expect(newArray[0]).toBe(array[1]);
                expect(newArray[2]).toBe(array[3]);
            });
            it('should ignore `end` if undefined', function(){
                var newArray = Ext.Array.slice(array, 1, undefined);
                expect(newArray.length).toBe(3);
                expect(newArray[0]).toBe(array[1]);
                expect(newArray[2]).toBe(array[3]);
            });
            it('should ignore `begin` if undefined', function(){
                var newArray = Ext.Array.slice(array, undefined);
                expect(newArray.length).toBe(4);
                expect(newArray[0]).toBe(array[0]);
                expect(newArray[3]).toBe(array[3]);
            });
            it('should ignore `begin` and `end` if undefined', function(){
                var newArray = Ext.Array.slice(array, undefined, undefined);
                expect(newArray.length).toBe(4);
                expect(newArray[0]).toBe(array[0]);
                expect(newArray[3]).toBe(array[3]);
            });
            it('should slice out the middle', function(){
                var newArray = Ext.Array.slice(array, 1, -1);
                expect(newArray.length).toBe(2);
                expect(newArray[0]).toBe(array[1]);
                expect(newArray[1]).toBe(array[2]);
            });
        }
    });

    describe('toMap', function () {
        it('should handle just an array', function () {
            var map = Ext.Array.toMap(['a','b','c']);

            expect(map.a).toEqual(1);
            expect(map.b).toEqual(2);
            expect(map.c).toEqual(3);

            delete map.a;
            delete map.b;
            delete map.c;

            expect(Ext.encode(map)).toEqual('{}');
        });
        it('should handle just an array and a property name', function () {
            var map = Ext.Array.toMap([
                { name: 'aaa' },
                { name: 'bbb' },
                { name: 'ccc' }
            ], 'name');

            expect(map.aaa).toEqual(1);
            expect(map.bbb).toEqual(2);
            expect(map.ccc).toEqual(3);

            delete map.aaa;
            delete map.bbb;
            delete map.ccc;

            expect(Ext.encode(map)).toEqual('{}');
        });
        it('should handle just an array and a key extractor', function () {
            var map = Ext.Array.toMap([
                { name: 'aaa' },
                { name: 'bbb' },
                { name: 'ccc' }
            ], function (obj) {
                return obj.name.toUpperCase();
            });

            expect(map.AAA).toEqual(1);
            expect(map.BBB).toEqual(2);
            expect(map.CCC).toEqual(3);

            delete map.AAA;
            delete map.BBB;
            delete map.CCC;

            expect(Ext.encode(map)).toEqual('{}');
        });
    });
    
    describe('flatten', function() {
        var flatten = Ext.Array.flatten;
        it('should convert a multi-dimensional array into 1-d array', function() {
            expect(flatten([
                            1,
                            [2,3],
                            [4,[5,6]]
                            ])).toEqual([1,2,3,4,5,6]);
        });
    });

    describe(&quot;Ext.Array.push&quot;, function() {
        var push = Ext.Array.push;

        it(&quot;should create an array&quot;, function(){
            expect(push(undefined, 1)).toEqual([1]);
        });

        it(&quot;should convert a non-array to an array&quot;, function() {
            expect(push(1, 2)).toEqual([1, 2]);
        });

        it(&quot;should push single elements onto end&quot;, function() {
            expect(push([1, 2], 3, 4, 5)).toEqual([1, 2, 3, 4, 5]);
        });

        it(&quot;should push all items of array arguments onto end&quot;, function(){
            expect(push([1, 2], [3, 4], [5])).toEqual([1, 2, 3, 4, 5]);
        });

        it(&quot;should push arrays and single items into the end&quot;, function(){
            expect(push([1, 2], [3, 4], 5)).toEqual([1, 2, 3, 4, 5]);
        });
    });
});
</pre>
</body>
</html>
